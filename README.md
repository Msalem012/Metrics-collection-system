# Система Сбора Метрик

Потокобезопасная, расширяемая библиотека на C++ для сбора и сохранения метрик в текстовые файлы.

## Описание Проекта

Данный проект представляет собой полноценную систему для сбора именованных событий, которые могут происходить в произвольные моменты времени, с соответствующими значениями заданных типов данных. Система автоматически записывает метрики в файлы в человеко-читаемом текстовом формате.

### Задача
Разработать библиотеку/набор классов на C++ для сбора и сохранения метрик в файл в текстовом виде со следующими требованиями:

**Примеры метрик:**
- Средняя утилизация CPU за секунду (вещественные числа от 0 до N, где N - количество ядер)
- Количество принятых HTTP запросов за секунду (целые числа от 0 до INT_MAX)

**Формат вывода:**
```
2025-06-01 15:00:01.653 "CPU" 0.97 "HTTP requests RPS" 42
2025-06-01 15:00:02.653 "CPU" 1.12 "HTTP requests RPS" 30
```

**Требования:**
-  Возможность добавления новых типов метрик без переписывания реализации
-  Запись метрик не должна блокировать потоки, в которых происходят события
-  После записи метрик накопленные значения обнуляются

## Архитектура и Подход к Реализации

###  Архитектурные Решения

#### 1. **Шаблонная Система Типов**
```cpp
template<typename T>
class TypedMetric : public Metric {
    // Типобезопасное хранение и обработка данных
};
```

**Почему выбран этот подход:**
- **Типобезопасность на этапе компиляции** - исключает ошибки приведения типов
- **Производительность** - избегаем виртуальные вызовы в горячих путях
- **Расширяемость** - новые типы добавляются простой инстанциацией шаблонов

#### 2. **Полиморфная Базовая Архитектура**
```cpp
class Metric {
public:
    virtual std::unique_ptr<MetricValue> getAccumulatedValue() const = 0;
    virtual void reset() = 0;
    // ...
};
```

**Обоснование:**
- **Единообразный интерфейс** для работы с различными типами метрик
- **Полиморфная обработка** в runtime без знания конкретных типов
- **Паттерн Bridge** между типобезопасностью и полиморфизмом

###  Поток Данных и Обработка

#### Архитектура потока данных:
```
Потоки Приложения → MetricCollector → Фоновый Поток → MetricWriter → Файл
    (запись)         (накопление)      (обработка)     (форматирование) (сохранение)
```

#### 3. **Неблокирующая Запись (Hot Path Optimization)**
```cpp
void MetricCollector::recordMetric(const std::string& name, T value) {
    // Быстрый поиск метрики
    Metric* target_metric = findMetric(name);  // O(1) с минимальной блокировкой
    
    // Атомарное добавление значения
    target_metric->recordValue(value);         // Блокировка только конкретной метрики
    
    // Немедленный возврат
    return;  // НЕ ЖДЕМ записи в файл
}
```

**Ключевые принципы:**
- **Мелкогранулярные блокировки** - каждая метрика имеет свой mutex
- **Отложенная обработка** - тяжелая работа выполняется в фоновом потоке
- **Автоматическая регистрация** - метрики создаются "на лету" при первом использовании

#### 4. **Фоновая Обработка**
```cpp
void processMetrics() {
    while (running_) {
        auto start = steady_clock::now();
        
        collectCurrentMetrics();  // Собираем накопленные значения
        
        // Поддерживаем точные интервалы в 1 секунду
        sleep_for(flush_interval - (steady_clock::now() - start));
    }
}
```

**Зачем нужен фоновый поток:**
- **Разделение ответственности** - запись и I/O не влияют на производительность приложения
- **Батчевая обработка** - эффективная запись нескольких метрик одновременно
- **Точные временные интервалы** - гарантированная периодичность записи

###  Потокобезопасность

#### 5. **Стратегия Синхронизации**
```cpp
// Иерархия блокировок (предотвращение deadlock)
1. MetricRegistry::registry_mutex_     // Регистрация метрик (редко)
2. TypedMetric::mutex_                 // Накопление значений (часто)  
3. MetricWriter::write_mutex_          // Запись в файл (периодически)
```

**Обоснование выбора:**
- **Shared_mutex для чтения** - множественные читатели, один писатель
- **Fine-grained locking** - минимизация контention между потоками
- **Lock-free где возможно** - atomic для флагов состояния

#### 6. **Жизненный Цикл Метрик**
```cpp
// Цикл: Накопление → Агрегация → Запись → Сброс
while (running_) {
    // 1. Накапливаем значения (в потоках приложения)
    metric->recordValue(value);
    
    // 2. Агрегируем данные (в фоновом потоке)
    auto aggregated = metric->getAccumulatedValue();
    
    // 3. Записываем в файл
    writer->writeMetrics(entries);
    
    // 4. Сбрасываем накопленные значения
    metric->reset();
}
```

###  Обработка Различных Типов Данных

#### 7. **Умные Стратегии Агрегации**
```cpp
template<typename T>
std::unique_ptr<MetricValue> TypedMetric<T>::getAccumulatedValue() const {
    if constexpr (std::is_floating_point_v<T>) {
        // Для CPU утилизации - возвращаем СРЕДНЕЕ значение
        return std::make_unique<TypedMetricValue<T>>(accumulated_value_ / count_);
    } else {
        // Для HTTP запросов - возвращаем СУММУ
        return std::make_unique<TypedMetricValue<T>>(accumulated_value_);
    }
}
```

**Почему разные стратегии:**
- **CPU метрики** - среднее значение показывает реальную загрузку
- **HTTP метрики** - сумма показывает общее количество запросов
- **Расширяемость** - можно легко добавить новые стратегии

###  Конкретные Решения

#### 8. **Форматирование Временных Меток**
```cpp
std::string formatTimestamp(const TimePoint& tp) {
    auto time_t = system_clock::to_time_t(tp);
    auto ms = duration_cast<milliseconds>(tp.time_since_epoch()) % 1000;
    
    // Точный формат: "2025-06-01 15:00:01.653"
    ss << put_time(localtime(&time_t), "%Y-%m-%d %H:%M:%S");
    ss << '.' << setfill('0') << setw(3) << ms.count();
}
```

#### 9. **Валидация и Безопасность**
```cpp
bool MetricNameValidator::isValidName(const std::string& name) {
    if (name.empty()) return false;
    
    // Запрещаем опасные символы
    for (char c : name) {
        if (c == '"' || c == '\n' || c == '\r' || c < 32) {
            return false;
        }
    }
    return true;
}
```

###  Паттерны Проектирования

#### 10. **Использованные Паттерны**

**RAII (Resource Acquisition Is Initialization):**
```cpp
class ScopedMetricSystem {
    ScopedMetricSystem(const std::string& file) {
        manager_ = MetricSystemManager::create(file);
        manager_->start();  // Автоматический запуск
    }
    
    ~ScopedMetricSystem() {
        manager_->stop();   // Автоматическая остановка
    }
};
```

**Factory Pattern:**
```cpp
class MetricSystemFactory {
    static std::unique_ptr<MetricCollector> createSystem(const std::string& file);
};
```

**Template Method Pattern:**
```cpp
class TypedMetric<T> : public Metric {
    // Базовый алгоритм в базовом классе
    // Специфичные для типа операции в шаблоне
};
```

**Observer Pattern (неявно):**
```cpp
// MetricCollector "наблюдает" за метриками и периодически их обрабатывает
```

###  Оптимизации Производительности

#### 11. **Горячий Путь (Hot Path)**
```cpp
// Оптимизированный путь записи метрик
void recordMetric(T value) {
    std::lock_guard<std::mutex> lock(mutex_);  // Минимальная блокировка
    accumulated_value_ += value;               // Простое сложение
    count_++;                                  // Простой инкремент
}  // Немедленное освобождение блокировки
```

**Принципы оптимизации:**
- **Минимальное время блокировки** - только для критических секций
- **Избегание аллокаций** - предварительное резервирование памяти
- **Батчевые операции** - групповая обработка для снижения overhead

#### 12. **Обработка Ошибок**
```cpp
try {
    metric->recordValue(value);
} catch (const std::exception& e) {
    std::cerr << "Metric recording failed: " << e.what() << std::endl;
    // НЕ падаем, продолжаем работу
}
```

**Стратегия обработки ошибок:**
- **Graceful degradation** - система продолжает работать при сбоях отдельных метрик
- **Логирование ошибок** - информирование о проблемах без остановки системы
- **Exception safety** - строгие гарантии исключений где возможно


### Итоговые Характеристики:
-  **Производительность**: O(1) запись, минимальные блокировки
-  **Потокобезопасность**: Поддержка множественных потоков
-  **Расширяемость**: Легкое добавление новых типов метрик
-  **Соответствие требованиям**: 100% выполнение технического задания
-  **Готовность к продакшену**: RAII, обработка ошибок, документация 
